# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ImpactAnalysisDockWidget
                                 A QGIS plugin
 Impact analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-05-16
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Bo Victor Thomsen, AestasGIS Denmark
        email                : bvt@aestas.dk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.uic import loadUiType
from PyQt5.QtCore import pyqtSignal, Qt, pyqtSlot, QVariant
from PyQt5.QtWidgets import QMenu, QActionGroup, QAction, QToolButton, QApplication, QAbstractItemView, QTreeWidgetItem, QDockWidget, QTreeWidgetItemIterator, QApplication, QWidget, QFileDialog
from PyQt5.QtGui import QIcon, QImage
from PyQt5.QtXml import QDomDocument
from .helper import hLog, hInfo, hWarning, hCritical, readConfig, tr, removeGroup, addMemoryLayer2tree, addMemoryLayer2treeNG, cnvobj2wkt, wkbtype2simple, cnvobj2obj, fillResultTree, clearGroupLayer, removeGroupLayer
import os.path
from inspect import currentframe
from .mapTools import AddPointTool, CaptureTool
from qgis.core import QgsProject, QgsLayerTreeGroup,QgsMapLayer, QgsLayerDefinition, QgsFeature, QgsExpressionContextUtils, QgsVirtualLayerDefinition, QgsVectorLayer, QgsField, QgsPrintLayout, QgsReadWriteContext, QgsLayoutExporter
import datetime



FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(__file__), 'impact_analysis_dockwidget_base.ui'))

class ImpactAnalysisDockWidget(QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self,parent,iface):
        """Constructor."""
        super(ImpactAnalysisDockWidget, self).__init__(parent)

        # Local references to QGIS iface and parent 
        self.iface = iface
        self.currentProfile = None
        self.currentGeom = None
        self.currentBuffer = None
        self.curFeature = []
        
        # User interface setup
        self.setupUi(self)

        # Menu for toolbutton 
        self.pmSearchobj = QMenu(self)

        # First set of menu actions (Actiongroup agSearchobj): Draw polygon .. Previous object
        self.agSearchobj = QActionGroup(self)
        self.acPol  = self.agSearchobj.addAction(QAction(QIcon(':/plugins/{0}/icons/Icons8-Ios7-Maps-Polygon.ico'.format(__package__)),tr('Draw polygon'),self,checkable=True))
        self.acLin  = self.agSearchobj.addAction(QAction(QIcon(':/plugins/{0}/icons/Icons8-Ios7-Maps-Polyline.ico'.format(__package__)),tr('Draw line'),self,checkable=True))
        self.acPnt  = self.agSearchobj.addAction(QAction(QIcon(':/plugins/{0}/icons/Icons8-Ios7-Maps-Geo-Fence.ico'.format(__package__)),tr('Draw point'),self,checkable=True))
        self.acAlay = self.agSearchobj.addAction(QAction(QIcon(':/plugins/{0}/icons/Icons8-Ios7-Maps-Layers.ico'.format(__package__)),tr('Active selection'),self,checkable=True))
        self.acPobj = self.agSearchobj.addAction(QAction(QIcon(':/plugins/{0}/icons/Icons8-Ios7-Maps-Quest.ico'.format(__package__)),tr('Previous object'),self,checkable=True))
        self.pmSearchobj.addActions(self.agSearchobj.actions());
        self.agSearchobj.setExclusive(True)
        # Menu separator
        self.pmSearchobj.addSeparator()

        # Second set of menu action : Use overlapping objects from administrative layer
        self.acOvl = QAction(tr('Use as a pointer to administrative layer'),self,checkable=True) 

        self.pmSearchobj.addAction(self.acOvl)

        # connect trigger function for menu
        self.agSearchobj.triggered.connect(self.xx_agSearchobj_triggered)    
        self.acOvl.triggered.connect(self.xx_acOvl_triggered)    

        # Attach menu to search toolbutton and set style for button 
        self.pbSearchobj.setMenu(self.pmSearchobj)
        self.pbSearchobj.setPopupMode(QToolButton.MenuButtonPopup)
        self.pbSearchobj.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        self.pbSearchobj.clicked.connect(self.xx_pbSearchobj_clicked)    

        # connect trigger function for clear
        self.pbClear.clicked.connect(self.xx_pbClear_clicked)  

        # Setup for Copy button
        self.agCopy = QActionGroup(self)
        self.acMapClipboard = self.agCopy.addAction(QAction(tr(u'Canvas bitmap/clipboard'),self,checkable=True))
        self.acClipboard = self.agCopy.addAction(QAction(tr(u'CSV/clipboard'),self,checkable=True))
        self.acPdfFile = self.agCopy.addAction(QAction(tr(u'PDF file'),self,checkable=True))
        self.agCopy.setExclusive(True)

        # Create sub menu for button "Copy"
        self.pmCopy = QMenu(self)
        self.pmCopy.addActions(self.agCopy.actions());
        self.acClipboard.setChecked(True)

        # Attach menu to toolbutton and set style for button 
        self.pbCopy.setMenu(self.pmCopy)
        self.pbCopy.setPopupMode(QToolButton.MenuButtonPopup)
        self.pbCopy.setToolButtonStyle(Qt.ToolButtonTextOnly)

        # Connect signal and slot for action group
        self.agCopy.triggered.connect(self.xx_agCopy_triggered) 
        self.pbCopy.clicked.connect(self.xx_pbCopy_clicked) 
        
        # Setup for Zoom button
        self.agZoomobj = QActionGroup(self)
        self.acEntire = self.agZoomobj.addAction(QAction(tr(u'To entire object'),self,checkable=True))
        self.acOverlap = self.agZoomobj.addAction(QAction(tr(u'Only to overlap'),self,checkable=True))
        self.agZoomobj.setExclusive(True)

        # Create sub menu for button "Zoom"
        self.pmZoomobj = QMenu(self)
        self.pmZoomobj.addActions(self.agZoomobj.actions());
        self.acEntire.setChecked(True)

        # Attach menu to toolbutton and set style for button 
        self.pbZoomobj.setMenu(self.pmZoomobj)
        self.pbZoomobj.setPopupMode(QToolButton.MenuButtonPopup)
        self.pbZoomobj.setToolButtonStyle(Qt.ToolButtonTextOnly)

        # Connect signal and slot for action group
        self.agZoomobj.triggered.connect(self.xx_agZoomobj_triggered) 
        self.pbZoomobj.clicked.connect(self.xx_pbZoomobj_clicked) 

        # Setup for Link button
        self.agWeblink = QActionGroup(self)
        self.acLink1 = self.agWeblink.addAction(QAction(tr(u'URL/filelink 1'),self,checkable=True))
        self.acLink2 = self.agWeblink.addAction(QAction(tr(u'URL/filelink 2'),self,checkable=True))
        self.agWeblink.setExclusive(True)

        # Create sub menu for button "Link"
        self.pmWeblink = QMenu(self)
        self.pmWeblink.addActions(self.agWeblink.actions());
        self.acLink1.setChecked(True)

        # Attach menu to toolbutton and set style for button 
        self.pbWeblink.setMenu(self.pmWeblink)
        self.pbWeblink.setPopupMode(QToolButton.MenuButtonPopup)
        self.pbWeblink.setToolButtonStyle(Qt.ToolButtonTextOnly)

        # Connect signal and slot for action group
        self.agWeblink.triggered.connect(self.xx_agWeblink_triggered) 
        self.pbWeblink.clicked.connect(self.xx_pbWeblink_clicked) 
       
        # Connect signal and slot for profile combobox
        self.cbProfiles.currentIndexChanged.connect(self.xx_cbProfiles_currentIndexChanged)

        # Connect signal and slot for tree widgets
        self.twResult.currentItemChanged.connect(self.xx_twResult_currentItemChanged)
        
        # Read the configuration file (json object)        
        self.config = readConfig()   
              
        if self.config is not None:
            # Populate the cbProfiles combobox
            self.cbProfiles.clear()
            for k in self.config['profiles']:
                self.cbProfiles.addItem(k)

            self.cbProfiles.setCurrentIndex(0)   

    def xx_agCopy_triggered(self, action):
        self.xx_pbCopy_clicked()  
            
    def xx_pbCopy_clicked(self):

        if self.acClipboard.isChecked():
            
            # Format
            st = u"{}\t{}\t{}\t{}\n"

            # Headerline        
            s = st.format('layername','value','http1','http2')
            sLayer = '"#¤%&/()='
            iterator = QTreeWidgetItemIterator(self.twResult)
            while iterator.value():
                item = iterator.value()
                if item.parent() is None: # Root item
                    sRoot = item.text(0)

                elif item.parent().text(0) == sRoot: # New layer
                    sLayer = item.text(2)

                elif item.checkState(0)>0:
                    s += st.format(sLayer,item.text(0),item.text(2),item.text(3))
                else:
                    pass

                iterator += 1
                
            cb = QApplication.clipboard() 
            cb.clear(mode=cb.Clipboard )
            cb.setText(s, mode=cb.Clipboard)
            hInfo(tr(u'Impact Analysis'),tr(u'Data copied to the clipboard; change to the desired program and use Ctrl+V'),3)
            
        elif self.acMapClipboard.isChecked():
            QApplication.clipboard().setImage(QImage(QWidget.grab(self.iface.mapCanvas())))
            hInfo(tr(u'Impact Analysis'),tr(u'Map copied to the clipboard; change to the desired program and use Ctrl+V'),3)

        else:
            root = QgsProject.instance().layerTreeRoot()
            group = root.findGroup(self.config['analysis']['group']['name'])

            # Create 2 geometryless layers to chosen layers and objects
            lDict = self.config['analysis']['layers']

            lLname = lDict['layername']
            lNumber = lDict['number']
            lSelected = lDict['selected']

#            removeGroupLayer(self.config['analysis']['group']['name'],layer):            
            ll = addMemoryLayer2treeNG (lDict['name'], [QgsField(lLname,QVariant.String), QgsField(lNumber,QVariant.Int), QgsField(lSelected,QVariant.Int)], group, True)
            ld = ll.dataProvider()
            lf = QgsFeature(ld.fields())

            oDict = self.config['analysis']['objects']

            oLname = oDict['layername']
            oResult = oDict['result']
            oUrl1 = oDict['url1']
            oUrl2 = oDict['url2']
            
            ol = addMemoryLayer2treeNG (oDict['name'], [QgsField(oLname,QVariant.String), QgsField(oResult,QVariant.String), QgsField(oUrl1,QVariant.String), QgsField(oUrl2,QVariant.String)], group, True)
            od = ol.dataProvider()
            of = QgsFeature(od.fields())

            sLayer = '"#¤%&/()='
            iterator = QTreeWidgetItemIterator(self.twResult)
            while iterator.value():
                item = iterator.value()
                if item.parent() is None: # Root item
                    sRoot = item.text(0)

                elif item.parent().text(0) == sRoot: # New layer

                    if sLayer != '"#¤%&/()=':
                        # Udskriv lagoplysninger
                        lf[lLname]    = sLayer
                        lf[lNumber]   = nNumber
                        lf[lSelected] = nSelected
                        ld.addFeature(lf)

                    sLayer = item.text(2)
                    nNumber = int(item.text(3))
                    nSelected = 0                    

                elif item.checkState(0)>0:
                    nSelected += 1
                    of[oLname]  = sLayer
                    of[oResult] = item.text(0)
                    of[oUrl1]   = item.text(2)
                    of[oUrl2]   = item.text(3)
                    od.addFeature(of)
                else:
                    pass

                iterator += 1
                
            if sLayer != '"#¤%&/()=':
                # Udskriv lagoplysninger
                lf[lLname]    = sLayer
                lf[lNumber]   = nNumber
                lf[lSelected] = nSelected
                ld.addFeature(lf)

            # Find report json
            rDict = self.config['reports']['PDF file']

            # Generate pdf file name
            pdfFile = str(rDict["directory"]) + '/' + datetime.datetime.now().strftime("%Y_%m_%d_%H_%M_%S") + '.pdf'

            if str(rDict["dialog"]).lower() == 'true':
                path = QFileDialog.getSaveFileName(self,tr(u'Save PDF file to '),pdfFile, 'PDF (*.pdf);;All files (*.*)')
                pdfFile = path[0]

       
            # create layout and print pdf
            if pdfFile != '':
                printFile = self.printTemplate (self.config['path']+'/'+rDict['template'],pdfFile)
                hInfo(tr(u'Impact Analysis'),tr(u'PDF file generated: ')+printFile,13)
                            

                
                
    @pyqtSlot(QTreeWidgetItem, QTreeWidgetItem)
    def xx_twResult_currentItemChanged(self, current, previous):

        self.curFeature = []

        try:
            p1 = str(current.parent().text(1))
            if p1 != 'root':    
                self.curFeature.append(str(current.text(0)))
                self.curFeature.append(str(current.text(1)))
                self.curFeature.append(str(current.text(2)))
                self.curFeature.append(str(current.text(3)))
                self.curFeature.append(p1)
                
        except:
            pass

    def xx_agWeblink_triggered(self, action):
        self.xx_pbWeblink_clicked()  

    def xx_pbWeblink_clicked(self):

        if self.curFeature != []:

            # Find url value
            url = self.curFeature[2] if self.acLink1.isChecked() else self.curFeature[3]
            if url != '':
                try:
                    os.startfile(url)
                except:
                    hWarning (tr('Illegal URL-value'),tr('Value is: ')+url,6)
            else:
                hWarning (tr('Blank URL-value'),tr(''),6)
 
    def xx_agZoomobj_triggered(self, action):
        self.xx_pbZoomobj_clicked()  

    def xx_pbZoomobj_clicked(self):

        if self.curFeature != []:

            l = QgsProject.instance().layerTreeRoot().findLayer(self.curFeature[4]).layer()
            
            # Find map EPSG
            epsg = self.iface.mapCanvas().mapSettings().destinationCrs().authid()    
               
            # Find result object
            f = l.getFeature(long(self.curFeature[1]))
            geom = cnvobj2obj(f.geometry(),l.crs().authid(),epsg)

            aDict = self.config['analysis']
            
            # If result layer exist, then remove it for existing object
            layers = QgsProject.instance().mapLayersByName(aDict['zoomto']['name'])
            for lz in layers:
                removeGroupLayer(aDict['group']['name'],lz)

            # Add zoomto layer and geometry
            zl = addMemoryLayer2tree (geom.wkbType(), epsg, aDict['zoomto']['name'], self.config['path']+'/'+aDict['zoomto']['style_'+wkbtype2simple(geom.wkbType())],QgsProject.instance().layerTreeRoot().findGroup(aDict['group']['name']), True)
            f = QgsFeature(zl.dataProvider().fields())
            f['id'] = 1
            f.setGeometry(geom)
            zl.dataProvider().addFeature(f)
            zl.updateExtents()             
    
            # If necessary, modify conflict object using intersection with zoom object
            if self.acOverlap.isChecked() and wkbtype2simple(geom.type()) != 'pnt':
                geom = geom.intersection(self.currentBuffer)
    
            # Buffer af geom for at finde kortstørrelse-rektangel
            geom = geom.buffer(float(aDict['zoomto']['buffer']), 3).boundingBox()
    
            # Find kort
            mc = self.iface.mapCanvas()
    
            # Sæt extend af kort og refresh
            mc.setExtent(geom)
            mc.refresh()
            
            self.iface.setActiveLayer(l)
            self.iface.actionIdentify().trigger()
            
            
        else:
            hWarning (tr('Item zoom'),tr('No item selected'),3)
        
    def xx_pbClear_clicked(self):

        self.twResult.clear()
        removeGroup(self.config['analysis']['group']['name'])
    
    def xx_cbProfiles_currentIndexChanged(self,i):

        # Fetch scenario name
        pDict = self.config['profiles'][self.cbProfiles.currentText()]

        # Set buffer value
        self.dsbBuffer.setValue(pDict['buffer'])
        
        # Set the appropriate draw action and run the trigger function
        action = self.agSearchobj.actions()[pDict['tool']]
        action.setChecked(True)
        self.agSearchobj_triggered(action)

        # Set the appropriate searchtype action and run the trigger function
        self.acOvl.setChecked(pDict['type'] == 1)
        self.xx_acOvl_triggered()

    def agSearchobj_triggered (self,action):

        if action.isChecked():
            icon = QIcon(action.icon())   
            self.pbSearchobj.setIcon (icon)      
            self.pbSearchobj.setText (action.text() + '->[]' if self.acOvl.isChecked() else action.text()) 

    def xx_agSearchobj_triggered(self,action):

        self.agSearchobj_triggered(action)
        self.xx_pbSearchobj_clicked()        

    def xx_acOvl_triggered (self):

        txt = self.pbSearchobj.text().replace("->[]","")
        self.pbSearchobj.setText (txt + '->[]' if self.acOvl.isChecked() else txt)                    

    def xx_pbSearchobj_clicked(self):

        removeGroup(self.config['analysis']['group']['name'])
        
        geoms =  None
        
        # Which tool is activated ?  
        if self.acPol.isChecked():    # "Draw polygon" is checked
            tool = CaptureTool(self.iface.mapCanvas(), self.geometryAdded, CaptureTool.CAPTURE_POLYGON)
            self.iface.mapCanvas().setMapTool(tool)        
        elif self.acLin.isChecked():  # "Draw line" is checked
            tool = CaptureTool(self.iface.mapCanvas(), self.geometryAdded, CaptureTool.CAPTURE_LINE)
            self.iface.mapCanvas().setMapTool(tool)        
        elif self.acPnt.isChecked():  # "Draw point" is checked
            tool = AddPointTool(self.iface.mapCanvas(), self.geometryAdded)
            self.iface.mapCanvas().setMapTool(tool)        
        elif self.acAlay.isChecked(): # "Use active layer selection" is checked
            geoms = None
            layer = self.iface.activeLayer()
            if (layer) and (layer.type() == QgsMapLayer.VectorLayer):
                selection = layer.selectedFeatures()
                if (selection):
                    # Combine geometries in collection
                    for f in selection:
                        if geoms == None:
                            geoms = f.geometry()
                        else:
                            geoms = geoms.combine( f.geometry() )

            if (geoms != None):
                self.geometryAdded(geoms) # Activate the result dialog immediately            
            else:
                hCritical(tr('Impact Analysis'),tr('No selected vector objects found in active layer'),3)
                self.xx_cbProfiles_currentIndexChanged(self.cbProfiles.currentIndex()) # Leave system in legal state
        elif self.acPobj.isChecked():     # "Use previous search object" is checked
            geoms = self.currentGeom
            if (geoms != None):
                self.geometryAdded(geoms) # Activate the result dialog immediately            
            else:
                hCritical(tr('Impact Analysis'),tr('No existing search object found'),3)
                self.xx_cbProfiles_currentIndexChanged(self.cbProfiles.currentIndex()) # Leave system in legal state
        else:
            # We should never reach this code path...
            hCritical(tr('Impact Analysis'),tr('Unknown search tool'),6)
            self.xx_cbProfiles_currentIndexChanged(self.cbProfiles.currentIndex()) # Leave system in legal state
       
       
    def geometryAdded(self, geom):
        
        if not geom is None:    
            QApplication.setOverrideCursor(Qt.WaitCursor)
            # Find EPSG projection id
            epsg = self.iface.mapCanvas().mapSettings().destinationCrs().authid()    

            aDict = self.config['analysis']
        
            #removeGroup(aDict['group'])

            # Create new layergroup with conflict layer
            group = QgsLayerTreeGroup(aDict['group']['name'], True)
            cl = addMemoryLayer2tree (geom.wkbType(), epsg, aDict['conflict']['name'], self.config['path']+'/'+aDict['conflict']['style_'+wkbtype2simple(geom.wkbType())], group, True)
            f = QgsFeature(cl.dataProvider().fields())
            f['id'] = 1
            f.setGeometry(geom)
            cl.dataProvider().addFeature(f)
            cl.updateExtents()             
            
            # Save geometry object for future reference
            self.currentGeom = geom

            # Change geometry to a collection of objects from administrative layer if necessary
            if self.acOvl.isChecked():
                alDict = self.config['adm_layer']
                geom = self.convertGeom2AdmCollection(geom,epsg,alDict['uri'],alDict['type'],alDict['epsg'])

            if not geom is None:            


                # check and correct buffervalue compared with geometry type
                self.dsbBuffer.setValue(self.checkBufferValue(geom,0.1,self.dsbBuffer.value()))
                
                # Buffer the conflict geometry with the chosen buffersize
                geomb = geom.buffer (self.dsbBuffer.value(),4) if self.dsbBuffer.value() != 0.0 else geom
                self.currentBuffer = geomb
                
                bl = addMemoryLayer2tree (geomb.wkbType(), epsg, aDict['buffer']['name'], self.config['path']+'/'+aDict['buffer']['style_'+wkbtype2simple(geomb.wkbType())], group, False)
                f = QgsFeature(bl.dataProvider().fields())
                f['id'] = 1
                f.setGeometry(geomb)
                bl.dataProvider().addFeature(f)
                bl.updateExtents()             

                # Set project variable with conflict name
                QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(),'impact_analysis',self.cbProfiles.currentText())
                    
                # Add the conflict group to the project 
                root = QgsProject.instance().layerTreeRoot()
                root.insertChildNode(0, group)

                group2 = group.addGroup (self.cbProfiles.currentText())
                
                # Set active tool to Pan
                self.iface.actionPan().trigger()
                
                pDict = self.config['profiles'][self.cbProfiles.currentText()]

                group3 = QgsLayerTreeGroup()
                QgsLayerDefinition.loadLayerDefinition(self.config['path']+'/'+pDict['file'],QgsProject.instance(), group3) 

                twr = self.twResult

                twr.clear()
                twr.setUniformRowHeights(True)
                twr.setAlternatingRowColors(True)
                twr.header().setStretchLastSection(True)
                twr.setEditTriggers(QAbstractItemView.NoEditTriggers)
                
                # For all childs nodes in group if it is a layer
                layers = group3.findLayers()
                
                tree = QTreeWidgetItem(twr)
                tree.setText(0,tr(u'{} ({} layers)').format(self.cbProfiles.currentText(),len(layers)))
                tree.setText(1,'root')
                tree.setFlags( Qt.ItemIsEnabled| Qt.ItemIsUserCheckable | Qt.ItemIsTristate )

                tree.setCheckState(0, Qt.Unchecked)

                vl = 0
                # Iterate all the layers to find the conflictlayers
                for nl in layers:

                    l = nl.layer()
                    vl += 1                                              

                    # Check if layer variable 'IA_conflict' is present and set vith a value
                    layerVar = QgsExpressionContextUtils.layerScope(l).variable('IA_conflict')
                    if (not layerVar is None):
                
                        # Find org. EPSG
                        lepsg=l.dataProvider().crs().authid()
                       
                        # Change in desperate times
                        lepsg = epsg if lepsg == '' or lepsg.find('1000') > -1 else lepsg
                        
                        # Convert geomb to wkt in original layer epsg
                        wktb = cnvobj2wkt(geomb,epsg,lepsg)
                
                        # Set filter using virtual layers
                        df = QgsVirtualLayerDefinition()
                        df.addSource('vl{0}'.format(vl), l.source(), l.dataProvider().name() )
                        df.setQuery("select * from vl{0} a where a._search_frame_ = geomfromwkt('{1}')  and Intersects(a.geometry,geomfromwkt('{1}')) = 1".format(vl,wktb))
                        l.setDataSource(df.toString(), l.name(), 'virtual')
                        QgsProject.instance().addMapLayer(l, False)
                        nl = group2.addLayer(l)

                        fillResultTree (tree, l, nl.layerId(), layerVar, 'result_col', 'url1_col', 'url2_col')
                        
                tree.setExpanded(True)        
            QApplication.restoreOverrideCursor()

        
    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
         
    def convertGeom2AdmCollection (self,geom,epsg,sourcea,typea,epsga):

        geoms = None
        
        
        # If geom is a line or point convert to small polygon
        if geom.type() <= 2:
            geom = geom.buffer(0.1,4)
            
        # Convert geom til wkt with layer projection
        wkt = cnvobj2wkt (geom,epsg,epsga)
        
        df = QgsVirtualLayerDefinition()
        df.addSource( 'vlx', sourcea, typea)
        df.setQuery("select * from vlx a where a._search_frame_ = geomfromwkt('{0}')  and Intersects(a.geometry,geomfromwkt('{0}')) = 1".format(wkt))
        alayer= QgsVectorLayer (df.toString(), 'vlx', "virtual")
        
        for q in alayer.getFeatures():
            if geoms == None:
                geoms = q.geometry()
            else:
                geoms = geoms.combine( q.geometry())

        
        if geoms is None:
            hCritical(tr('Impact Analysis'), tr('No objects in adminstrative layer overlaps the search object'),20)
            return None
        else:
            geoms = geoms.buffer(-0.1,4)
            return cnvobj2obj(geoms,epsga,epsg)
                
    def checkBufferValue (self, geom, minval, nuvval):
    
        # Find geometry type
        gtx = -1 if geom == None else geom.type()
        
        # Check/set value: type = point/line, orginal object user is true and value less than min value        
        if gtx in [0,1] and minval > nuvval:
            hWarning(tr('Impact Analysis'),tr('Buffersize changed.. Original value ({}) changed to minimum buffer value ({}) for point and lines').format(nuvval,minval),3)
            return minval
        else:
            return nuvval

    def printTemplate (self, template, pdfFile):
        
        project = QgsProject.instance()
        composition = QgsPrintLayout(project)
        document = QDomDocument()

        rDict = self.config['reports']['PDF file']
        lDict = self.config['analysis']['layers']
        oDict = self.config['analysis']['objects']

        if pdfFile != '':

            # read template content
            template_file = open(template)
            template_content = template_file.read()
            template_file.close()
            document.setContent(template_content)
    
            # load layout from template and add to Layout Manager
            composition.loadFromTemplate(document, QgsReadWriteContext()) 
    
            # Set map to main map extends
            kort = composition.itemById('map')
            kort.setExtent(self.iface.mapCanvas().extent())        
    
            # Set tema attribute table to correct layer
            temaer = composition.itemById('layers')
            temaer_attr =  project.mapLayersByName(lDict['name'])[0]
            temaer_item = temaer.multiFrame ()   
            temaer_item.setVectorLayer(temaer_attr)        
            temaer_item.setDisplayedFields([lDict['layername'],lDict['number'],lDict['selected']])
            for i in range(3):
                col = temaer_item.columns()[i] 
                col.setWidth(rDict["lwidth"][i])
            
            # Set object attribute table to correct layer
            objekter = composition.itemById('objects')
            objekter_attr =  project.mapLayersByName(oDict['name'])[0]
            objekter_item = objekter.multiFrame ()   
            objekter_item.setVectorLayer(objekter_attr)        
            objekter_item.setDisplayedFields([oDict['layername'],oDict['result'],oDict['url1'],oDict['url2']])
            for i in range(4):
                col = objekter_item.columns()[i] 
                col.setWidth(rDict["owidth"][i])
    
    
            exporter = QgsLayoutExporter(composition)
            exporter.exportToPdf(pdfFile,QgsLayoutExporter.PdfExportSettings())
            project.removeMapLayers([temaer_attr.id(),objekter_attr.id()])
            
        return pdfFile 
        